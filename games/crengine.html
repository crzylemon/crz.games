<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>CRENGINE</title>
<style>
    body { margin: 0; overflow: hidden; font-family: 'Courier New', monospace; }
    canvas { display: block; background: #222; }
    #console {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 50%;
        background: rgba(0, 0, 0, 0.9);
        color: #0f0;
        padding: 10px;
        box-sizing: border-box;
        display: none;
        flex-direction: column;
    }
    #console-output {
        flex: 1;
        overflow-y: auto;
        font-size: 12px;
        line-height: 1.4;
        white-space: pre-wrap;
    }
    #console-input {
        background: transparent;
        border: none;
        color: #0f0;
        font-family: inherit;
        font-size: 12px;
        outline: none;
        padding: 5px 0;
    }
    #console-suggestions {
        background: rgba(0, 0, 0, 0.8);
        color: #0f0;
        font-size: 11px;
        max-height: 100px;
        overflow-y: auto;
        display: none;
    }
    .suggestion {
        padding: 2px 5px;
        cursor: pointer;
    }
    .suggestion:hover {
        background: rgba(0, 255, 0, 0.2);
    }
    #console-input::before {
        content: "] ";
    }
    #gamecontainer {
        width: 800px;
        height: 600px;
        position: relative;
        margin: 0 auto;
        border: 1px solid #333;
    }
    #gameCanvas {
        width: 100%;
        height: 100%;
        display: block;
    }
</style>
</head>
<body>
    <div id="gamecontainer" width="800" height="600">
        <canvas id="gameCanvas"></canvas>
        <div id="console">
            <div id="console-output"></div>
            <div id="console-suggestions"></div>
            <input type="text" id="console-input" placeholder="] Enter command...">
        </div>
    </div>
<script>
class CRE {
    constructor(canvas, game) {
        this.canvas = canvas;
        this.container = document.getElementById("gamecontainer");
        this.ctx = canvas.getContext("2d");
        this.keys = {};
        this.entities = [];
        this.EntityClasses = {};
        this.RUN_TYPE = "CLIENT"; // Can be CLIENT, SERVER, SHARED
        this.consoleOpen = false;
        this.consoleHistory = [];
        this.Transform = Transform;
        this.conCommands = {};
        this.conVars = {};
        this.game = game;
        this._width = canvas.width;
        this._height = canvas.height;
        console.log("CRE initialized for game:", game);
        console.log("this.game: ", this.game);
        
        // 3D Camera
        this.camera = {
            position: new Vector(0, 0, -10),
            rotation: new Vector(0, 0, 0),
            fov: 60,
            near: 0.01,
            far: 1000
        };

        // Setup input
        window.addEventListener("keydown", e => {
            if (!this.consoleOpen) this.keys[e.key] = true;
        });
        window.addEventListener("keyup", e => {
            if (!this.consoleOpen) this.keys[e.key] = false;
        });

        // Set canvas size to match container
        this.updateCanvasSize();
        
        // Handle resize
        window.addEventListener('resize', () => this.updateCanvasSize());
        
        // Property setters for width/height
        Object.defineProperty(this, 'width', {
            get: () => this._width,
            set: (value) => {
                this._width = value;
                this.canvas.width = value;
                this.container.style.width = value + 'px';
            }
        });
        
        Object.defineProperty(this, 'height', {
            get: () => this._height,
            set: (value) => {
                this._height = value;
                this.canvas.height = value;
                this.container.style.height = value + 'px';
            }
        });

        // Enums for registration
        this.Enums = {
            RunType: {
                CLIENT: "CLIENT",
                SERVER: "SERVER",
                SHARED: "SHARED"
            }
        };

        // Start game loop
        this.lastTime = performance.now();
        requestAnimationFrame(this.gameLoop.bind(this));
    }

    updateCanvasSize() {
        const rect = this.container.getBoundingClientRect();
        this.canvas.width = rect.width;
        this.canvas.height = rect.height;
    }
    
    // Register a class as an entity
    RegisterEntity(cls, name, runType = this.Enums.RunType.CLIENT) {
        this.EntityClasses[name] = { cls, runType };
    }

    ConsoleHandler(command, ...args) {
        this.addToConsole(`] ${command} ${args.join(' ')}`);
        
        // Check registered commands first
        if (this.conCommands[command]) {
            this.conCommands[command](...args);
            return;
        }
        
        // Check convars
        if (this.conVars[command]) {
            if (args.length > 0) {
                this.conVars[command].value = args[0];
                this.addToConsole(`${command} = ${args[0]}`);
            } else {
                this.addToConsole(`${command} = ${this.conVars[command].value}`);
            }
            return;
        }
        
        switch (command) {
            case "ent_spawn":
                this.SpawnEntity(args[0], ...args.slice(1));
                break;
            case "game_reset":
                this.UTIL_RESET();
                break;
            case "ent_remove":
                const entity = this.entities.find(e => e.name === args[0]);
                if (entity) this.UTIL_REMOVE(entity);
                break;
            case "clear":
                document.getElementById('console-output').textContent = '';
                break;
            case "map_load":
                fetch(`uploads/games/${this.game}/maps/${args[0]}.map?v=${Date.now()}`)
                    .then(r => r.json())
                    .then(data => this.LoadMap(data))
                    .catch(() => this.addToConsole(`Failed to load map: ${args[0]}`));
                break;
            case "width":
                if (args[0]) this.width = parseInt(args[0]);
                this.addToConsole(`Width = ${this.width}`);
                break;
            case "height":
                if (args[0]) this.height = parseInt(args[0]);
                this.addToConsole(`Height = ${this.height}`);
                break;
            default:
                this.addToConsole(`Unknown command: ${command}`);
        }
    }

    addToConsole(text) {
        const output = document.getElementById('console-output');
        output.textContent += text + '\n';
        output.scrollTop = output.scrollHeight;
    }

    toggleConsole() {
        this.consoleOpen = !this.consoleOpen;
        const console = document.getElementById('console');
        const input = document.getElementById('console-input');
        const suggestions = document.getElementById('console-suggestions');
        
        if (this.consoleOpen) {
            console.style.display = 'flex';
            input.focus();
        } else {
            console.style.display = 'none';
            input.blur();
            suggestions.style.display = 'none';
        }
    }

    // Add an instance of a registered entity
    SpawnEntity(name, ...args) {
        if (!this.EntityClasses[name]) {
            console.warn(`Entity ${name} not registered!`);
            return null;
        }
        const { cls, runType } = this.EntityClasses[name];
        // Only spawn if run type matches
        if (runType === this.RUN_TYPE || runType === this.Enums.RunType.SHARED) {
            const instance = new cls(...args);
            if (instance.init) instance.init();
            this.entities.push(instance);
            return instance;
        }
        return null;
    }

    // Check if a key is pressed
    isKeyPressed(key) {
        return !!this.keys[key];
    }
    
    // Register console command
    RegisterConCommand(name, func) {
        this.conCommands[name] = func;
    }
    
    // Register console variable
    RegisterConVar(name, defaultValue) {
        this.conVars[name] = { value: defaultValue };
        return this.conVars[name];
    }
    
    // Get convar value
    GetConVar(name) {
        return this.conVars[name] ? this.conVars[name].value : null;
    }
    
    // Load map from JSON
    LoadMap(mapData) {
        this.UTIL_RESET();
        this.brushes = [];
        
        // Load entities
        mapData.entities?.forEach(ent => {
            const instance = this.SpawnEntity(ent.type, ...ent.args || []);
            if (instance && ent.position) {
                instance.transform?.setPosition(...ent.position);
            }
            if (instance && ent.scale) {
                instance.transform?.setScale(...ent.scale);
            }
        });
        
        // Load brushes
        mapData.brushes?.forEach(brush => {
            this.brushes.push({
                vertices: brush.vertices.map(v => new Vector(v[0], v[1], v[2])),
                texture: brush.texture || "#666",
                faces: brush.faces || []
            });
        });
        
        this.Msg(`Loaded map: ${mapData.name || 'unnamed'}`);
    }

    // Utility functions
    Msg(text) { 
        console.log(text);
        if (this.consoleOpen) this.addToConsole(text);
    }
    UTIL_RESET() { this.Msg("Game Reset!"); this.entities = []; }
    UTIL_REMOVE(entity) { this.entities = this.entities.filter(e => e !== entity); }
    
    // Simple GUI system
    drawGUI() {
        this.ctx.fillStyle = "white";
        this.ctx.font = "12px monospace";
        this.ctx.fillText(`Entities: ${this.entities.length}`, 10, 20);
        
        // Calculate FPS with proper bounds
        const frameTime = performance.now() - this.lastTime;
        const fps = frameTime > 0 ? Math.min(Math.round(1000 / frameTime), 999) : 0;
        const addplus = fps === 999 ? "+" : "";
        this.ctx.fillText(`FPS: ${fps}${addplus}`, 10, 35);
        
        if (this.camera.position) {
            this.ctx.fillText(`Pos: ${this.camera.position.x.toFixed(1)}, ${this.camera.position.y.toFixed(1)}, ${this.camera.position.z.toFixed(1)}`, 10, 50);
        }
        if (this.camera.rotation) {
            this.ctx.fillText(`Rot: ${this.camera.rotation.x.toFixed(1)}, ${this.camera.rotation.y.toFixed(1)}, ${this.camera.rotation.z.toFixed(1)}`, 10, 65);
        }
    }

    // 3D projection with camera rotation
    project3D(pos) {
        const cx = this.canvas.width / 2;
        const cy = this.canvas.height / 2;
        const f = cx / Math.tan(this.camera.fov * Math.PI / 360);
        
        // Translate relative to camera
        let d = pos.subtract(this.camera.position);
        
        // Apply camera rotation
        const yaw = this.camera.rotation.y * Math.PI / 180;
        const pitch = this.camera.rotation.x * Math.PI / 180;
        
        // Rotate around Y axis (yaw)
        const cosY = Math.cos(-yaw);
        const sinY = Math.sin(-yaw);
        const x1 = d.x * cosY - d.z * sinY;
        const z1 = d.x * sinY + d.z * cosY;
        
        // Rotate around X axis (pitch)
        const cosX = Math.cos(-pitch);
        const sinX = Math.sin(-pitch);
        const y2 = d.y * cosX - z1 * sinX;
        const z2 = d.y * sinX + z1 * cosX;
        
        if (z2 <= this.camera.near) return null; // Behind near plane
        
        return new Vector(
            cx + (x1 * f) / z2,
            cy - (y2 * f) / z2,
            z2
        );
    }
    
    drawLine3D(pos1, pos2) {
        const p1 = this.project3D(pos1);
        const p2 = this.project3D(pos2);
        
        if (p1 && p2) {
            this.ctx.beginPath();
            this.ctx.moveTo(p1.x, p1.y);
            this.ctx.lineTo(p2.x, p2.y);
            this.ctx.stroke();
        }
    }
    
    // Clip triangle against near plane
    clipTriangle(v1, v2, v3) {
        // Transform to camera space
        const cam1 = this.toCameraSpace(v1);
        const cam2 = this.toCameraSpace(v2);
        const cam3 = this.toCameraSpace(v3);
        
        const near = this.camera.near;
        const verts = [cam1, cam2, cam3];
        const clipped = [];
        
        // Simple near plane clipping
        for (let i = 0; i < 3; i++) {
            const curr = verts[i];
            const next = verts[(i + 1) % 3];
            
            if (curr.z >= near) {
                clipped.push(curr);
                
                if (next.z < near) {
                    // Clip edge
                    const t = (near - curr.z) / (next.z - curr.z);
                    clipped.push({
                        x: curr.x + t * (next.x - curr.x),
                        y: curr.y + t * (next.y - curr.y),
                        z: near
                    });
                }
            } else if (next.z >= near) {
                // Clip edge
                const t = (near - curr.z) / (next.z - curr.z);
                clipped.push({
                    x: curr.x + t * (next.x - curr.x),
                    y: curr.y + t * (next.y - curr.y),
                    z: near
                });
            }
        }
        
        return clipped;
    }
    
    toCameraSpace(pos) {
        let d = pos.subtract(this.camera.position);
        
        const yaw = this.camera.rotation.y * Math.PI / 180;
        const pitch = this.camera.rotation.x * Math.PI / 180;
        
        const cosY = Math.cos(-yaw);
        const sinY = Math.sin(-yaw);
        const x1 = d.x * cosY - d.z * sinY;
        const z1 = d.x * sinY + d.z * cosY;
        
        const cosX = Math.cos(-pitch);
        const sinX = Math.sin(-pitch);
        const y2 = d.y * cosX - z1 * sinX;
        const z2 = d.y * sinX + z1 * cosX;
        
        return { x: x1, y: y2, z: z2 };
    }
    
    drawTriangle3D(v1, v2, v3, color = "white", shading = 1) {
        const clipped = this.clipTriangle(v1, v2, v3);
        
        if (clipped.length >= 3) {
            // Project clipped vertices
            const projected = clipped.map(v => {
                const cx = this.canvas.width / 2;
                const cy = this.canvas.height / 2;
                const f = cx / Math.tan(this.camera.fov * Math.PI / 360);
                
                return {
                    x: cx + (v.x * f) / v.z,
                    y: cy - (v.y * f) / v.z
                };
            });
            
            // Apply shading
            let shadedColor = color;
            if (color.startsWith('#')) {
                const r = parseInt(color.slice(1, 3), 16) * shading;
                const g = parseInt(color.slice(3, 5), 16) * shading;
                const b = parseInt(color.slice(5, 7), 16) * shading;
                shadedColor = `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
            }
            
            this.ctx.fillStyle = shadedColor;
            this.ctx.strokeStyle = shadedColor;
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            this.ctx.moveTo(projected[0].x, projected[0].y);
            for (let i = 1; i < projected.length; i++) {
                this.ctx.lineTo(projected[i].x, projected[i].y);
            }
            this.ctx.closePath();
            this.ctx.fill();
            this.ctx.stroke();
        }
    }
    
    // Apply rotation to a vertex
    rotateVertex(vertex, rotation, center) {
        let v = vertex.subtract(center);
        
        // Rotate around Y axis (yaw) - reversed
        const yaw = -rotation.y * Math.PI / 180;
        const cosY = Math.cos(yaw);
        const sinY = Math.sin(yaw);
        const x1 = v.x * cosY - v.z * sinY;
        const z1 = v.x * sinY + v.z * cosY;
        
        // Rotate around X axis (pitch) - reversed
        const pitch = -rotation.x * Math.PI / 180;
        const cosX = Math.cos(pitch);
        const sinX = Math.sin(pitch);
        const y2 = v.y * cosX - z1 * sinX;
        const z2 = v.y * sinX + z1 * cosX;
        
        // Rotate around Z axis (roll) - reversed
        const roll = -rotation.z * Math.PI / 180;
        const cosZ = Math.cos(roll);
        const sinZ = Math.sin(roll);
        const x3 = x1 * cosZ - y2 * sinZ;
        const y3 = x1 * sinZ + y2 * cosZ;
        
        return center.add(new Vector(x3, y3, z2));
    }
    
    drawCube3D(transform) {
        const pos = new Vector(transform.position.x, transform.position.y, transform.position.z);
        const scale = transform.scale;
        const rotation = transform.rotation;
        
        // Base cube vertices (unrotated)
        const baseVertices = [
            new Vector(-scale.x, -scale.y, -scale.z), new Vector(scale.x, -scale.y, -scale.z),
            new Vector(scale.x, scale.y, -scale.z), new Vector(-scale.x, scale.y, -scale.z),
            new Vector(-scale.x, -scale.y, scale.z), new Vector(scale.x, -scale.y, scale.z),
            new Vector(scale.x, scale.y, scale.z), new Vector(-scale.x, scale.y, scale.z)
        ];
        
        // Apply rotation and position
        const v = baseVertices.map(vertex => 
            this.rotateVertex(pos.add(vertex), rotation, pos)
        );
        
        // Create faces with z-depth for sorting
        const faces = [
            {verts: [v[0],v[1],v[2]], shade: 0.6}, {verts: [v[0],v[2],v[3]], shade: 0.6}, // back
            {verts: [v[4],v[7],v[6]], shade: 1.0}, {verts: [v[4],v[6],v[5]], shade: 1.0}, // front
            {verts: [v[0],v[4],v[5]], shade: 0.4}, {verts: [v[0],v[5],v[1]], shade: 0.4}, // bottom
            {verts: [v[2],v[6],v[7]], shade: 0.9}, {verts: [v[2],v[7],v[3]], shade: 0.9}, // top
            {verts: [v[0],v[3],v[7]], shade: 0.7}, {verts: [v[0],v[7],v[4]], shade: 0.7}, // left
            {verts: [v[1],v[5],v[6]], shade: 0.8}, {verts: [v[1],v[6],v[2]], shade: 0.8}  // right
        ];
        
        // Calculate camera-space Z depth for each face and add to render queue
        faces.forEach(({verts: [a,b,c], shade}) => {
            // Use the same transformation as project3D for consistent depth
            const p1 = this.project3D(a);
            const p2 = this.project3D(b);
            const p3 = this.project3D(c);
            if (p1 && p2 && p3) {
                // Backface culling - check if triangle faces away from camera
                const v1 = new Vector(p2.x - p1.x, p2.y - p1.y, 0);
                const v2 = new Vector(p3.x - p1.x, p3.y - p1.y, 0);
                const cross = v1.x * v2.y - v1.y * v2.x;
                
                // Only render front-facing triangles
                if (cross < 0) {
                    const maxZ = Math.max(p1.z, p2.z, p3.z);
                    this.renderQueue.push({type: 'triangle', verts: [a,b,c], color: "#888888", shade, z: maxZ});
                }
            }
        });
    }

    // Main game loop
    gameLoop(now) {
        const dt = (now - this.lastTime) / 1000;
        this.lastTime = now;

        // Update entities
        this.entities.forEach(ent => {
            if (ent.update) ent.update(dt, this);
        });

        // Clear and prepare render queue
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.renderQueue = [];
        
        // Add brushes to render queue
        if (this.brushes) {
            this.brushes.forEach(brush => {
                brush.faces.forEach(face => {
                    for (let i = 1; i < face.length - 1; i++) {
                        const v1 = brush.vertices[face[0]];
                        const v2 = brush.vertices[face[i]];
                        const v3 = brush.vertices[face[i + 1]];
                        // Use the same transformation as project3D for consistent depth
                        const p1 = this.project3D(v1);
                        const p2 = this.project3D(v2);
                        const p3 = this.project3D(v3);
                        if (p1 && p2 && p3) {
                            // Use the farthest vertex for more stable sorting
                            const maxZ = Math.max(p1.z, p2.z, p3.z);
                            this.renderQueue.push({type: 'triangle', verts: [v1,v2,v3], color: brush.texture, shade: 1, z: maxZ});
                        }
                    }
                });
            });
        }
        
        // Add 3D entities to render queue
        this.entities.forEach(ent => {
            if (ent.transform) {
                this.drawCube3D(ent.transform);
            } else if (ent.draw) {
                ent.draw(this.ctx);
            }
        });
        
        // Sort by Z depth (farthest first) and render
        this.renderQueue.sort((a, b) => b.z - a.z);
        this.renderQueue.forEach(item => {
            if (item.type === 'triangle') {
                this.drawTriangle3D(item.verts[0], item.verts[1], item.verts[2], item.color, item.shade);
            }
        });
        
        // Draw GUI
        this.drawGUI();

        requestAnimationFrame(this.gameLoop.bind(this));
    }
}
class Transform {
    constructor() {
        this.position = { x: 0, y: 0, z: 0 };
        this.rotation = { x: 0, y: 0, z: 0 };
        this.scale = { x: 1, y: 1, z: 1 };
    }
    getPosition() { return this.position; }
    setPosition(x, y, z) { this.position = { x, y, z }; }
    getRotation() { return this.rotation; }
    setRotation(x, y, z) { this.rotation = { x, y, z }; }
    getScale() { return this.scale; }
    setScale(x, y, z) { this.scale = { x, y, z }; }
    // Add other methods that might be useful
    getForwardVector() {
        const yaw = this.rotation.y * Math.PI / 180;
        const pitch = this.rotation.x * Math.PI / 180;

        return {
            x: Math.sin(yaw) * Math.cos(pitch),
            y: -Math.sin(pitch),
            z: Math.cos(yaw) * Math.cos(pitch)
        };
    }

    getRightVector() {
        const yaw = (this.rotation.y + 90) * Math.PI / 180;

        return {
            x: Math.sin(yaw),
            y: 0,
            z: Math.cos(yaw)
        };
    }

    getUpVector() {
        return { x: 0, y: 1, z: 0 };
    }

}
class Vector {
    constructor(x = 0, y = 0, z = 0) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    add(v) {
        return new Vector(this.x + v.x, this.y + v.y, this.z + v.z);
    }

    subtract(v) {
        return new Vector(this.x - v.x, this.y - v.y, this.z - v.z);
    }

    multiply(scalar) {
        return new Vector(this.x * scalar, this.y * scalar, this.z * scalar);
    }

    divide(scalar) {
        return new Vector(this.x / scalar, this.y / scalar, this.z / scalar);
    }

    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }

    normalize() {
        const len = this.length();
        if (len === 0) return new Vector(0, 0, 0);
        return this.divide(len);
    }
}


const urlParams = new URLSearchParams(window.location.search);
const gameName = urlParams.get('game') || 'game';
// --- Initialize CRE ---
const cre = new CRE(document.getElementById("gameCanvas"), gameName);
console.log("CRENGINE initialized");
console.log("Loading game:", gameName);
window.CRE = cre; // Make CRE instance globally available

// Get game name from URL parameter


fetch(`uploads/games/${gameName}/bin/client.cre?v=${Date.now()}`)
  .then(r => r.text())
  .then(code => new Function("CRE", code)(cre))
  .catch(() => {
    cre.Msg(`Failed to load ${gameName}/bin/client.cre, loading default game.cre`);
    return fetch(`game.cre?v=${Date.now()}`)
      .then(r => r.text())
      .then(code => new Function("CRE", code)(cre));
  }); 
// Console toggle and input handling
window.addEventListener("keydown", e => {
    if (e.key === "`") {
        e.preventDefault();
        cre.toggleConsole();
    }
});

const consoleInput = document.getElementById('console-input');
const suggestions = document.getElementById('console-suggestions');

consoleInput.addEventListener('input', e => {
    const input = e.target.value;
    if (input.length > 0) {
        const allCommands = [...Object.keys(cre.conCommands), ...Object.keys(cre.conVars), 'ent_spawn', 'game_reset', 'ent_remove', 'clear', 'map_load'];
        const matches = allCommands.filter(cmd => cmd.startsWith(input)).slice(0, 5);
        
        if (matches.length > 0) {
            suggestions.innerHTML = matches.map(cmd => `<div class="suggestion">${cmd}</div>`).join('');
            suggestions.style.display = 'block';
            
            // Add click handlers
            suggestions.querySelectorAll('.suggestion').forEach(el => {
                el.onclick = () => {
                    consoleInput.value = el.textContent;
                    suggestions.style.display = 'none';
                    consoleInput.focus();
                };
            });
        } else {
            suggestions.style.display = 'none';
        }
    } else {
        suggestions.style.display = 'none';
    }
});

consoleInput.addEventListener('keydown', e => {
    if (e.key === 'Enter') {
        const command = e.target.value.trim();
        if (command) {
            const parts = command.split(' ');
            cre.ConsoleHandler(parts[0], ...parts.slice(1));
            e.target.value = '';
            suggestions.style.display = 'none';
        }
    } else if (e.key === '`') {
        e.preventDefault();
        cre.toggleConsole();
    } else if (e.key === 'Escape') {
        suggestions.style.display = 'none';
    }
});

</script>
</body>
</html>
