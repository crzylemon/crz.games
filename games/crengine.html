<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>CRENGINE</title>
<style>
    html {width:fit-content; height:fit-content;}
    body { margin: 0; overflow: hidden; font-family: 'Courier New', monospace; width: fit-content; height: fit-content; }
    canvas { display: block; background: #222; }
    #console {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 50%;
        background: rgba(0, 0, 0, 0.9);
        color: #0f0;
        padding: 10px;
        box-sizing: border-box;
        display: none;
        flex-direction: column;
    }
    #console-output {
        flex: 1;
        overflow-y: auto;
        font-size: 12px;
        line-height: 1.4;
        white-space: pre-wrap;
    }
    #console-input {
        background: transparent;
        border: none;
        color: #0f0;
        font-family: inherit;
        font-size: 12px;
        outline: none;
        padding: 5px 0;
    }
    #console-suggestions {
        background: rgba(0, 0, 0, 0.8);
        color: #0f0;
        font-size: 11px;
        max-height: 100px;
        overflow-y: auto;
        display: none;
    }
    .suggestion {
        padding: 2px 5px;
        cursor: pointer;
    }
    .suggestion:hover {
        background: rgba(0, 255, 0, 0.2);
    }
    #console-input::before {
        content: "] ";
    }
    #gameCanvas {
        width: 100%;
        height: 100%;
        display: block;
    }
</style>
</head>
<body>
    <div id="gamecontainer" width="1280" height="720">
        <canvas id="gameCanvas"></canvas>
        <div id="console">
            <div id="console-output"></div>
            <div id="console-suggestions"></div>
            <input type="text" id="console-input" placeholder="] Enter command...">
        </div>
    </div>
<script>
class CRE {
    constructor(canvas, game) {
        this.canvas = canvas;
        this.container = document.getElementById("gamecontainer");
        this.ctx = canvas.getContext("2d");
        this.keys = {};
        this.entities = [];
        this.EntityClasses = {};
        this.RUN_TYPE = "CLIENT"; // Can be CLIENT, SERVER, SHARED
        this.consoleOpen = false;
        this.consoleHistory = [];
        this.Transform = Transform;
        this.conCommands = {};
        this.conVars = {};
        this.keyBinds = {};
        this.game = game;
        this.debug = false;
        // Load binds from localStorage
        this.loadBinds();
        this._width = 1280;
        this._height = 720;
        console.log("CRE initialized for game:", game);
        console.log("this.game: ", this.game);
        
        // 3D Camera
        this.camera = {
            position: new Vector(0, 0, -10),
            rotation: new Vector(0, 0, 0),
            fov: 60,
            near: 0.01,
            far: 1000
        };

        // Setup input
        window.addEventListener("keydown", e => {
            if (!this.consoleOpen) {
                this.keys[e.key] = true;
                // Check for key binds
                if (this.keyBinds[e.key.toLowerCase()]) {
                    this.ConsoleHandler(...this.keyBinds[e.key.toLowerCase()].split(' '));
                }
            }
        });
        window.addEventListener("keyup", e => {
            if (!this.consoleOpen) this.keys[e.key] = false;
        });

        // Set fixed canvas size
        this.canvas.width = this._width;
        this.canvas.height = this._height;
        this.container.style.width = this._width + 'px';
        this.container.style.height = this._height + 'px';
        
        // Property setters for width/height
        Object.defineProperty(this, 'width', {
            get: () => this._width,
            set: (value) => {
                this._width = value;
                this.canvas.width = value;
                this.container.style.width = value + 'px';
            }
        });
        
        Object.defineProperty(this, 'height', {
            get: () => this._height,
            set: (value) => {
                this._height = value;
                this.canvas.height = value;
                this.container.style.height = value + 'px';
            }
        });

        // Enums for registration
        this.Enums = {
            RunType: {
                CLIENT: "CLIENT",
                SERVER: "SERVER",
                SHARED: "SHARED"
            }
        };

        // Start game loop
        this.lastTime = performance.now();
        requestAnimationFrame(this.gameLoop.bind(this));
    }


    
    // Register a class as an entity
    RegisterEntity(cls, name, runType = this.Enums.RunType.CLIENT) {
        this.EntityClasses[name] = { cls, runType };
    }

    ConsoleHandler(command, ...args) {
        this.addToConsole(`] ${command} ${args.join(' ')}`);
        
        // Check registered commands first
        if (this.conCommands[command]) {
            this.conCommands[command](...args);
            return;
        }
        
        // Check convars
        if (this.conVars[command]) {
            if (args.length > 0) {
                this.conVars[command].value = args[0];
                this.addToConsole(`${command} = ${args[0]}`);
            } else {
                this.addToConsole(`${command} = ${this.conVars[command].value}`);
            }
            return;
        }
        
        switch (command) {
            case "ent_spawn":
                this.SpawnEntity(args[0], ...args.slice(1));
                break;
            case "game_reset":
                this.UTIL_RESET();
                break;
            case "ent_remove":
                const entity = this.entities.find(e => e.name === args[0]);
                if (entity) this.UTIL_REMOVE(entity);
                break;
            case "clear":
                document.getElementById('console-output').textContent = '';
                break;
            case "map_load":
                fetch(`uploads/games/${this.game}/maps/${args[0]}.map?v=${Date.now()}`)
                    .then(r => r.json())
                    .then(data => this.LoadMap(data))
                    .catch(() => this.addToConsole(`Failed to load map: ${args[0]}`));
                break;
            case "width":
                if (args[0]) this.width = parseInt(args[0]);
                this.addToConsole(`Width = ${this.width}`);
                break;
            case "height":
                if (args[0]) this.height = parseInt(args[0]);
                this.addToConsole(`Height = ${this.height}`);
                break;
            case "bind":
                if (args.length >= 2) {
                    const key = args[0].toLowerCase();
                    const command = args.slice(1).join(' ').replace(/"/g, '');
                    this.keyBinds[key] = command;
                    this.saveBinds();
                    this.addToConsole(`Bound ${key} to "${command}"`);
                } else {
                    this.addToConsole("Usage: bind <key> <command>");
                }
                break;
            case "unbind":
                if (args[0]) {
                    const key = args[0].toLowerCase();
                    if (this.keyBinds[key]) {
                        delete this.keyBinds[key];
                        this.saveBinds();
                        this.addToConsole(`Unbound ${key}`);
                    } else {
                        this.addToConsole(`${key} is not bound`);
                    }
                } else {
                    this.addToConsole("Usage: unbind <key>");
                }
                break;
            case "bindlist":
                if (Object.keys(this.keyBinds).length === 0) {
                    this.addToConsole("No key binds");
                } else {
                    Object.entries(this.keyBinds).forEach(([key, cmd]) => {
                        this.addToConsole(`${key} = "${cmd}"`);
                    });
                }
                break;
            case "toggledebug":
                this.debug = !this.debug;
                break;
            case "toggleconsole":
                this.toggleConsole();
                break;
            default:
                this.addToConsole(`Unknown command: ${command}`);
        }
    }

    addToConsole(text) {
        const output = document.getElementById('console-output');
        output.textContent += text + '\n';
        output.scrollTop = output.scrollHeight;
    }

    toggleConsole() {
        this.consoleOpen = !this.consoleOpen;
        const console = document.getElementById('console');
        const input = document.getElementById('console-input');
        const suggestions = document.getElementById('console-suggestions');
        
        if (this.consoleOpen) {
            console.style.display = 'flex';
            input.focus();
        } else {
            console.style.display = 'none';
            input.blur();
            suggestions.style.display = 'none';
        }
    }

    // Add an instance of a registered entity
    SpawnEntity(name, ...args) {
        if (!this.EntityClasses[name]) {
            console.warn(`Entity ${name} not registered!`);
            return null;
        }
        const { cls, runType } = this.EntityClasses[name];
        // Only spawn if run type matches
        if (runType === this.RUN_TYPE || runType === this.Enums.RunType.SHARED) {
            const instance = new cls(...args);
            if (instance.init) instance.init();
            this.entities.push(instance);
            return instance;
        }
        return null;
    }

    // Check if a key is pressed
    isKeyPressed(key) {
        return !!this.keys[key];
    }
    
    // Register console command
    RegisterConCommand(name, func) {
        this.conCommands[name] = func;
    }
    
    // Register console variable
    RegisterConVar(name, defaultValue) {
        this.conVars[name] = { value: defaultValue };
        return this.conVars[name];
    }
    
    // Get convar value
    GetConVar(name) {
        return this.conVars[name] ? this.conVars[name].value : null;
    }
    
    // Load map from JSON
    LoadMap(mapData) {
        this.UTIL_RESET();
        this.brushes = [];
        
        // Load entities
        mapData.entities?.forEach(ent => {
            const instance = this.SpawnEntity(ent.type, ...ent.args || []);
            if (instance && ent.position) {
                instance.transform?.setPosition(...ent.position);
            }
            if (instance && ent.scale) {
                instance.transform?.setScale(...ent.scale);
            }
        });
        
        // Load brushes
        mapData.brushes?.forEach(brush => {
            this.brushes.push({
                vertices: brush.vertices.map(v => new Vector(v[0], v[1], v[2])),
                texture: brush.texture || "#666",
                faces: brush.faces || []
            });
        });
        
        this.addToConsole(`Map loaded: ${mapData.name || 'Unnamed'}`);
    }
    
    // Auto-load map function for game code
    LoadMap(mapName) {
        fetch(`uploads/games/${this.game}/maps/${mapName}.map?v=${Date.now()}`)
            .then(r => r.json())
            .then(data => {
                this.LoadMap(data);
                console.log(`Auto-loaded map: ${mapName}`);
            })
            .catch(err => {
                console.warn(`Failed to auto-load map: ${mapName}`, err);
            });
    }
    
    // Save binds to localStorage
    saveBinds() {
        localStorage.setItem(`crengine_binds_${this.game}`, JSON.stringify(this.keyBinds));
    }
    
    // Load binds from localStorage
    loadBinds() {
        const saved = localStorage.getItem(`crengine_binds_${this.game}`);
        if (saved) {
            try {
                this.keyBinds = JSON.parse(saved);
            } catch (e) {
                console.warn('Failed to load saved binds:', e);
            }
        }
    }
    
    // Set default bind if not already set
    setDefaultBind(key, command) {
        const k = key.toLowerCase();
        if (!this.keyBinds[k]) {
            this.keyBinds[k] = command;
            this.saveBinds();
        }
    }

    // Utility functions
    Msg(text) { 
        console.log(text);
        if (this.consoleOpen) this.addToConsole(text);
    }
    UTIL_RESET() { this.Msg("Game Reset!"); this.entities = []; }
    UTIL_REMOVE(entity) { this.entities = this.entities.filter(e => e !== entity); }
    
    // Simple GUI system
    drawGUI() {
        if (this.debug) {
            this.ctx.fillStyle = "white";
            this.ctx.font = "12px monospace";
            this.ctx.fillText(`Entities: ${this.entities.length}`, 10, 20);
        
            // Calculate FPS with proper bounds
            const frameTime = performance.now() - this.lastTime;
            const fps = frameTime > 0 ? Math.min(Math.round(1000 / frameTime), 999) : 0;
            const addplus = fps === 999 ? "+" : "";
            this.ctx.fillText(`FPS: ${fps}${addplus}`, 10, 35);
        
            if (this.camera.position) {
                this.ctx.fillText(`Pos: ${this.camera.position.x.toFixed(1)}, ${this.camera.position.y.toFixed(1)}, ${this.camera.position.z.toFixed(1)}`, 10, 50);
            }
            if (this.camera.rotation) {
                this.ctx.fillText(`Rot: ${this.camera.rotation.x.toFixed(1)}, ${this.camera.rotation.y.toFixed(1)}, ${this.camera.rotation.z.toFixed(1)}`, 10, 65);
            }
        }
    }

    // 3D projection with camera rotation
    project3D(pos) {
        const cx = this.canvas.width / 2;
        const cy = this.canvas.height / 2;
        const f = cx / Math.tan(this.camera.fov * Math.PI / 360);
        
        // Translate relative to camera
        let d = pos.subtract(this.camera.position);
        
        // Apply camera rotation
        const yaw = this.camera.rotation.y * Math.PI / 180;
        const pitch = this.camera.rotation.x * Math.PI / 180;
        
        // Rotate around Y axis (yaw)
        const cosY = Math.cos(-yaw);
        const sinY = Math.sin(-yaw);
        const x1 = d.x * cosY - d.z * sinY;
        const z1 = d.x * sinY + d.z * cosY;
        
        // Rotate around X axis (pitch)
        const cosX = Math.cos(-pitch);
        const sinX = Math.sin(-pitch);
        const y2 = d.y * cosX - z1 * sinX;
        const z2 = d.y * sinX + z1 * cosX;
        
        if (z2 <= this.camera.near) return null; // Behind near plane
        
        return new Vector(
            cx + (x1 * f) / z2,
            cy - (y2 * f) / z2,
            z2
        );
    }
    
    drawLine3D(pos1, pos2) {
        const p1 = this.project3D(pos1);
        const p2 = this.project3D(pos2);
        
        if (p1 && p2) {
            this.ctx.beginPath();
            this.ctx.moveTo(p1.x, p1.y);
            this.ctx.lineTo(p2.x, p2.y);
            this.ctx.stroke();
        }
    }
    
    // Clip triangle against near plane
    clipTriangle(v1, v2, v3) {
        const near = this.camera.near;

        const verts = [
            this.toCameraSpace(v1),
            this.toCameraSpace(v2),
            this.toCameraSpace(v3)
        ];

        const inside = [];
        const outside = [];

        verts.forEach(v => {
            if (v.z >= near) inside.push(v);
            else outside.push(v);
        });

        // Fully clipped
        if (inside.length === 0) return [];

        // Fully visible
        if (inside.length === 3) return [[inside[0], inside[1], inside[2]]];

        // One inside → one triangle
        if (inside.length === 1 && outside.length === 2) {
            const i = inside[0];
            const o1 = outside[0];
            const o2 = outside[1];

            const t1 = (near - i.z) / (o1.z - i.z);
            const t2 = (near - i.z) / (o2.z - i.z);

            return [[
                i,
                { x: i.x + t1 * (o1.x - i.x), y: i.y + t1 * (o1.y - i.y), z: near },
                { x: i.x + t2 * (o2.x - i.x), y: i.y + t2 * (o2.y - i.y), z: near }
            ]];
        }

        // Two inside → quad → two triangles
        if (inside.length === 2 && outside.length === 1) {
            const [i1, i2] = inside;
            const o = outside[0];

            const t1 = (near - i1.z) / (o.z - i1.z);
            const t2 = (near - i2.z) / (o.z - i2.z);

            const v1 = { x: i1.x + t1 * (o.x - i1.x), y: i1.y + t1 * (o.y - i1.y), z: near };
            const v2 = { x: i2.x + t2 * (o.x - i2.x), y: i2.y + t2 * (o.y - i2.y), z: near };

            return [
                [i1, i2, v1],
                [i2, v2, v1]
            ];
        }

        return [];
    }

    toCameraSpace(pos) {
        let d = pos.subtract(this.camera.position);
        
        const yaw = this.camera.rotation.y * Math.PI / 180;
        const pitch = this.camera.rotation.x * Math.PI / 180;
        
        const cosY = Math.cos(-yaw);
        const sinY = Math.sin(-yaw);
        const x1 = d.x * cosY - d.z * sinY;
        const z1 = d.x * sinY + d.z * cosY;
        
        const cosX = Math.cos(-pitch);
        const sinX = Math.sin(-pitch);
        const y2 = d.y * cosX - z1 * sinX;
        const z2 = d.y * sinX + z1 * cosX;
        
        return { x: x1, y: y2, z: z2 };
    }
    
    drawTriangle3D(v1, v2, v3, color = "white", shading = 1) {
        // clipTriangle now returns an ARRAY OF TRIANGLES
        // each triangle = [{x,y,z},{x,y,z},{x,y,z}]
        const clippedTris = this.clipTriangle(v1, v2, v3);

        if (!clippedTris || clippedTris.length === 0) return;

        // Precompute projection constants
        const cx = this.canvas.width / 2;
        const cy = this.canvas.height / 2;
        const f = cx / Math.tan(this.camera.fov * Math.PI / 360);

        // Apply shading
        let shadedColor = color;
        if (color.startsWith('#')) {
            const clamp = v => Math.max(0, Math.min(255, v));
            const r = clamp(parseInt(color.slice(1, 3), 16) * shading);
            const g = clamp(parseInt(color.slice(3, 5), 16) * shading);
            const b = clamp(parseInt(color.slice(5, 7), 16) * shading);
            shadedColor = `rgb(${r|0}, ${g|0}, ${b|0})`;
        }

        this.ctx.fillStyle = shadedColor;
        this.ctx.strokeStyle = shadedColor;
        this.ctx.lineWidth = 1;

        // Draw each resulting triangle
        for (const tri of clippedTris) {
            const projected = tri.map(v => ({
                x: cx + (v.x * f) / v.z,
                y: cy - (v.y * f) / v.z
            }));

            this.ctx.beginPath();
            this.ctx.moveTo(projected[0].x, projected[0].y);
            this.ctx.lineTo(projected[1].x, projected[1].y);
            this.ctx.lineTo(projected[2].x, projected[2].y);
            this.ctx.closePath();
            this.ctx.fill();
            this.ctx.stroke();
        }
    }

    
    // Apply rotation to a vertex
    rotateVertex(vertex, rotation, center) {
        let v = vertex.subtract(center);
        
        // Rotate around Y axis (yaw) - reversed
        const yaw = -rotation.y * Math.PI / 180;
        const cosY = Math.cos(yaw);
        const sinY = Math.sin(yaw);
        const x1 = v.x * cosY - v.z * sinY;
        const z1 = v.x * sinY + v.z * cosY;
        
        // Rotate around X axis (pitch) - reversed
        const pitch = -rotation.x * Math.PI / 180;
        const cosX = Math.cos(pitch);
        const sinX = Math.sin(pitch);
        const y2 = v.y * cosX - z1 * sinX;
        const z2 = v.y * sinX + z1 * cosX;
        
        // Rotate around Z axis (roll) - reversed
        const roll = -rotation.z * Math.PI / 180;
        const cosZ = Math.cos(roll);
        const sinZ = Math.sin(roll);
        const x3 = x1 * cosZ - y2 * sinZ;
        const y3 = x1 * sinZ + y2 * cosZ;
        
        return center.add(new Vector(x3, y3, z2));
    }
    
    drawCube3D(transform) {
        const pos = new Vector(transform.position.x, transform.position.y, transform.position.z);
        const scale = transform.scale;
        const rotation = transform.rotation;
        
        // Base cube vertices (unrotated)
        const baseVertices = [
            new Vector(-scale.x, -scale.y, -scale.z), new Vector(scale.x, -scale.y, -scale.z),
            new Vector(scale.x, scale.y, -scale.z), new Vector(-scale.x, scale.y, -scale.z),
            new Vector(-scale.x, -scale.y, scale.z), new Vector(scale.x, -scale.y, scale.z),
            new Vector(scale.x, scale.y, scale.z), new Vector(-scale.x, scale.y, scale.z)
        ];
        
        // Apply rotation and position
        const v = baseVertices.map(vertex => 
            this.rotateVertex(pos.add(vertex), rotation, pos)
        );
        
        // Create faces with z-depth for sorting
        const faces = [
            {verts: [v[0],v[1],v[2]], shade: 0.6}, {verts: [v[0],v[2],v[3]], shade: 0.6}, // back
            {verts: [v[4],v[7],v[6]], shade: 1.0}, {verts: [v[4],v[6],v[5]], shade: 1.0}, // front
            {verts: [v[0],v[4],v[5]], shade: 0.4}, {verts: [v[0],v[5],v[1]], shade: 0.4}, // bottom
            {verts: [v[2],v[6],v[7]], shade: 0.9}, {verts: [v[2],v[7],v[3]], shade: 0.9}, // top
            {verts: [v[0],v[3],v[7]], shade: 0.7}, {verts: [v[0],v[7],v[4]], shade: 0.7}, // left
            {verts: [v[1],v[5],v[6]], shade: 0.8}, {verts: [v[1],v[6],v[2]], shade: 0.8}  // right
        ];
        
        // Calculate camera-space Z depth for each face and add to render queue
        faces.forEach(({verts: [a,b,c], shade}) => {
            // Use the same transformation as project3D for consistent depth
            const p1 = this.project3D(a);
            const p2 = this.project3D(b);
            const p3 = this.project3D(c);
            if (p1 && p2 && p3) {
                // Backface culling - check if triangle faces away from camera
                const ca = this.toCameraSpace(a);
                const cb = this.toCameraSpace(b);
                const cc = this.toCameraSpace(c);

                const abx = cb.x - ca.x;
                const aby = cb.y - ca.y;
                const abz = cb.z - ca.z;
                const acx = cc.x - ca.x;
                const acy = cc.y - ca.y;
                const acz = cc.z - ca.z;

                // Calculate proper cross product for normal
                const normalX = aby * acz - abz * acy;
                const normalY = abz * acx - abx * acz;
                const normalZ = abx * acy - aby * acx;
                
                // Calculate view direction from face center to camera (0,0,0 in camera space)
                const centerX = (ca.x + cb.x + cc.x) / 3;
                const centerY = (ca.y + cb.y + cc.y) / 3;
                const centerZ = (ca.z + cb.z + cc.z) / 3;
                
                // View direction points from face toward camera origin
                const viewX = -centerX;
                const viewY = -centerY;
                const viewZ = -centerZ;
                
                // Dot product between normal and view direction
                const dot = normalX * viewX + normalY * viewY + normalZ * viewZ;
                
                // Only render front-facing triangles
                if (dot < 0) {
                    const ca = this.toCameraSpace(a);
                    const cb = this.toCameraSpace(b);
                    const cc = this.toCameraSpace(c);

                    const minZ = Math.min(ca.z, cb.z, cc.z);
                    const maxZ = Math.max(ca.z, cb.z, cc.z);

                    this.renderQueue.push({
                        type: 'triangle',
                        verts: [a, b, c],
                        color: "#888888",
                        shade,
                        minZ,
                        maxZ
                    });
                }
            }
        });
    }

    // Main game loop
    gameLoop(now) {
        const dt = (now - this.lastTime) / 1000;
        this.lastTime = now;

        // Update entities
        this.entities.forEach(ent => {
            if (ent.update) ent.update(dt, this);
        });

        // Clear and prepare render queue
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.renderQueue = [];
        
        // Add brushes to render queue
        if (this.brushes) {
            this.brushes.forEach(brush => {
                brush.faces.forEach(face => {
                    for (let i = 1; i < face.length - 1; i++) {
                        const v1 = brush.vertices[face[0]];
                        const v2 = brush.vertices[face[i]];
                        const v3 = brush.vertices[face[i + 1]];
                        
                        // Calculate world space normal for lighting
                        const ab = v2.subtract(v1);
                        const ac = v3.subtract(v1);
                        const worldNormal = ab.cross(ac).normalize();
                        
                        // Calculate lighting in world space
                        const lightDir = new Vector(0.5, -1, 0.3).normalize();
                        const lightDot = worldNormal.dot(lightDir);
                        const shade = Math.max(0.3, Math.abs(lightDot));
                        
                        // Backface culling in camera space
                        const ca = this.toCameraSpace(v1);
                        const cb = this.toCameraSpace(v2);
                        const cc = this.toCameraSpace(v3);
                        
                        const abx = cb.x - ca.x, aby = cb.y - ca.y, abz = cb.z - ca.z;
                        const acx = cc.x - ca.x, acy = cc.y - ca.y, acz = cc.z - ca.z;
                        const normalX = aby * acz - abz * acy;
                        const normalY = abz * acx - abx * acz;
                        const normalZ = abx * acy - aby * acx;
                        
                        const centerX = (ca.x + cb.x + cc.x) / 3;
                        const centerY = (ca.y + cb.y + cc.y) / 3;
                        const centerZ = (ca.z + cb.z + cc.z) / 3;
                        
                        const dot = normalX * (-centerX) + normalY * (-centerY) + normalZ * (-centerZ);
                        
                        if (dot < 0) {
                            
                            const minZ = Math.min(ca.z, cb.z, cc.z);
                            const maxZ = Math.max(ca.z, cb.z, cc.z);

                            this.renderQueue.push({
                                type: 'triangle',
                                verts: [v1, v2, v3],
                                color: brush.texture,
                                shade,
                                minZ,
                                maxZ
                            });
                        }
                    }
                });
            });
        }
        
        // Add 3D entities to render queue
        this.entities.forEach(ent => {
            if (ent.transform) {
                this.drawCube3D(ent.transform);
            } else if (ent.draw) {
                ent.draw(this.ctx);
            }
        });
        
        // Sort by Z depth with intersection handling
        this.renderQueue.sort((a, b) => {
            if (a.minZ >= b.maxZ) return -1;
            if (b.minZ >= a.maxZ) return 1;
            
            // Check for triangle intersection
            if (this.trianglesIntersect(a, b)) {
                return this.compareIntersectingTriangles(a, b);
            }
            
            return b.maxZ - a.maxZ;
        });

        
        this.renderQueue.forEach(item => {
            if (item.type === 'triangle') {
                this.drawTriangle3D(item.verts[0], item.verts[1], item.verts[2], item.color, item.shade);
            }
        });
        
        // Draw GUI
        this.drawGUI();

        requestAnimationFrame(this.gameLoop.bind(this));
    }
    
    trianglesIntersect(a, b) {
        if (a.type !== 'triangle' || b.type !== 'triangle') return false;
        const [a1, a2, a3] = a.verts.map(v => this.toCameraSpace(v));
        const [b1, b2, b3] = b.verts.map(v => this.toCameraSpace(v));
        return this.triangleTriangleIntersect(a1, a2, a3, b1, b2, b3);
    }
    
    triangleTriangleIntersect(t1v1, t1v2, t1v3, t2v1, t2v2, t2v3) {
        const n1 = this.crossProduct(this.subtract(t1v2, t1v1), this.subtract(t1v3, t1v1));
        const d1 = -this.dotProduct(n1, t1v1);
        const dist2 = [t2v1, t2v2, t2v3].map(v => this.dotProduct(n1, v) + d1);
        const sign2 = dist2.map(d => Math.sign(d));
        if (sign2[0] === sign2[1] && sign2[1] === sign2[2] && sign2[0] !== 0) return false;
        
        const n2 = this.crossProduct(this.subtract(t2v2, t2v1), this.subtract(t2v3, t2v1));
        const d2 = -this.dotProduct(n2, t2v1);
        const dist1 = [t1v1, t1v2, t1v3].map(v => this.dotProduct(n2, v) + d2);
        const sign1 = dist1.map(d => Math.sign(d));
        if (sign1[0] === sign1[1] && sign1[1] === sign1[2] && sign1[0] !== 0) return false;
        
        return true;
    }
    
    compareIntersectingTriangles(a, b) {
        const aCentroid = this.getTriangleCentroid(a.verts);
        const bCentroid = this.getTriangleCentroid(b.verts);
        const aDepth = this.toCameraSpace(aCentroid).z;
        const bDepth = this.toCameraSpace(bCentroid).z;
        return bDepth - aDepth;
    }
    
    getTriangleCentroid(verts) {
        const [v1, v2, v3] = verts;
        return new Vector((v1.x + v2.x + v3.x) / 3, (v1.y + v2.y + v3.y) / 3, (v1.z + v2.z + v3.z) / 3);
    }
    
    crossProduct(a, b) {
        return { x: a.y * b.z - a.z * b.y, y: a.z * b.x - a.x * b.z, z: a.x * b.y - a.y * b.x };
    }
    
    dotProduct(a, b) {
        return a.x * b.x + a.y * b.y + a.z * b.z;
    }
    
    subtract(a, b) {
        return { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };
    }
}
class Transform {
    constructor() {
        this.position = { x: 0, y: 0, z: 0 };
        this.rotation = { x: 0, y: 0, z: 0 };
        this.scale = { x: 1, y: 1, z: 1 };
    }
    getPosition() { return this.position; }
    setPosition(x, y, z) { this.position = { x, y, z }; }
    getRotation() { return this.rotation; }
    setRotation(x, y, z) { this.rotation = { x, y, z }; }
    getScale() { return this.scale; }
    setScale(x, y, z) { this.scale = { x, y, z }; }
    // Add other methods that might be useful
    getForwardVector() {
        const yaw = this.rotation.y * Math.PI / 180;
        const pitch = this.rotation.x * Math.PI / 180;

        return {
            x: Math.sin(yaw) * Math.cos(pitch),
            y: -Math.sin(pitch),
            z: Math.cos(yaw) * Math.cos(pitch)
        };
    }

    getRightVector() {
        const yaw = this.rotation.y * Math.PI / 180;

        return {
            x: Math.cos(yaw),
            y: 0,
            z: -Math.sin(yaw)
        };
    }

    getUpVector() {
        return { x: 0, y: 1, z: 0 };
    }

}
class Vector {
    constructor(x = 0, y = 0, z = 0) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    add(v) {
        return new Vector(this.x + v.x, this.y + v.y, this.z + v.z);
    }
    
    dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
    }
    
    cross(v) {
        return new Vector(
            this.y * v.z - this.z * v.y,
            this.z * v.x - this.x * v.z,
            this.x * v.y - this.y * v.x
        );
    }

    subtract(v) {
        return new Vector(this.x - v.x, this.y - v.y, this.z - v.z);
    }

    multiply(scalar) {
        return new Vector(this.x * scalar, this.y * scalar, this.z * scalar);
    }

    divide(scalar) {
        return new Vector(this.x / scalar, this.y / scalar, this.z / scalar);
    }

    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }

    normalize() {
        const len = this.length();
        if (len === 0) return new Vector(0, 0, 0);
        return this.divide(len);
    }
}


const urlParams = new URLSearchParams(window.location.search);
const gameName = urlParams.get('game') || 'game';
// --- Initialize CRE ---
const cre = new CRE(document.getElementById("gameCanvas"), gameName);
console.log("CRENGINE initialized");
console.log("Loading game:", gameName);
window.CRE = cre; // Make CRE instance globally available

// Get game name from URL parameter


fetch(`uploads/games/${gameName}/bin/client.cre?v=${Date.now()}`)
  .then(r => r.text())
  .then(code => new Function("CRE", code)(cre))
  .catch(() => {
    cre.Msg(`Failed to load ${gameName}/bin/client.cre, loading default game.cre`);
    return fetch(`game.cre?v=${Date.now()}`)
      .then(r => r.text())
      .then(code => new Function("CRE", code)(cre));
  }); 
// Console toggle and input handling
window.addEventListener("keydown", e => {
    if (e.key === "`") {
        e.preventDefault();
        cre.toggleConsole();
    }
});

const consoleInput = document.getElementById('console-input');
const suggestions = document.getElementById('console-suggestions');
let selectedSuggestionIndex = 0;

consoleInput.addEventListener('input', e => {
    const input = e.target.value;
    if (input.length > 0) {
        const allCommands = [...Object.keys(cre.conCommands), ...Object.keys(cre.conVars), 'ent_spawn', 'game_reset', 'ent_remove', 'clear', 'map_load', 'width', 'height', 'bind', 'unbind', 'bindlist', 'toggledebug'];
        const matches = allCommands.filter(cmd => cmd.startsWith(input)).slice(0, 5);
        
        if (matches.length > 0) {
            suggestions.innerHTML = matches.map(cmd => `<div class="suggestion">${cmd}</div>`).join('');
            suggestions.style.display = 'block';
            
            // Add click handlers
            suggestions.querySelectorAll('.suggestion').forEach(el => {
                el.onclick = () => {
                    consoleInput.value = el.textContent;
                    suggestions.style.display = 'none';
                    consoleInput.focus();
                };
            });
        } else {
            suggestions.style.display = 'none';
        }
    } else {
        suggestions.style.display = 'none';
    }
});

consoleInput.addEventListener('keydown', e => {
    if (e.key === 'Tab') {
        e.preventDefault();

        const items = suggestions.querySelectorAll('.suggestion');
        if (items.length === 0) return;

        selectedSuggestionIndex %= items.length;
        consoleInput.value = items[selectedSuggestionIndex].textContent;
        selectedSuggestionIndex++;
        suggestions.style.display = 'none';
        consoleInput.focus();
        return;
    }

    if (e.key === 'Enter') {
        const command = e.target.value.trim();
        if (command) {
            const parts = command.split(' ');
            cre.ConsoleHandler(parts[0], ...parts.slice(1));
            e.target.value = '';
            suggestions.style.display = 'none';
            selectedSuggestionIndex = 0;
        }
    }
});

</script>
</body>
</html>
