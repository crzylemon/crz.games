<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>CRENGINE</title>
<style>
    html {width:fit-content; height:fit-content;}
    body { margin: 0; overflow: hidden; font-family: 'Courier New', monospace; width: fit-content; height: fit-content; }
    canvas { display: block; background: #222; }
    #console {
        position: absolute;
        top: 10px;
        left: 10px;
        width: calc(100% - 20px);
        height: calc(100% - 20px);
        background: rgba(0, 0, 0, 0.9);
        color: rgb(255, 255, 255);
        padding: 10px;
        box-sizing: border-box;
        display: none;
        flex-direction: column;
    }
    #console-output {
        flex: 1;
        overflow-y: auto;
        font-size: 12px;
        line-height: 1.4;
        white-space: pre-wrap;
    }
    #console-input {
        background: transparent;
        border: none;
        color: rgb(255, 255, 255);
        font-family: inherit;
        font-size: 12px;
        outline: none;
        padding: 5px 0;
    }
    #console-suggestions {
        background: rgba(0, 0, 0, 0.8);
        color: rgb(199, 199, 199);
        font-size: 11px;
        max-height: 100px;
        overflow-y: auto;
        display: none;
    }
    .suggestion {
        padding: 2px 5px;
        cursor: pointer;
    }
    .suggestion:hover {
        background: rgba(0, 255, 0, 0.2);
    }
    #console-input::before {
        content: "] ";
    }
    #gameCanvas {
        width: 100%;
        height: 100%;
        display: block;
    }
    #errorPopup {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.95);
        color: #f00;
        padding: 20px;
        border: 2px solid #f00;
        font-family: monospace;
        z-index: 1000;
        display: none;
        max-width: 80%;
        max-height: 80%;
        overflow: auto;
    }
    #errorPopup button {
        margin: 5px;
        padding: 10px;
        background: #333;
        color: #fff;
        border: 1px solid #666;
        cursor: pointer;
    }
</style>
</head>
<body>
    <div id="gamecontainer" width="1280" height="720">
        <canvas id="gameCanvas"></canvas>
        <div id="console">
            <div id="console-output"></div>
            <div id="console-suggestions"></div>
            <input type="text" id="console-input" placeholder="] Enter command...">
        </div>
    </div>
    <div id="errorPopup"></div>
<script>

class CRE {
    constructor(canvas, game) {
        this.crzgames = false; //running from crz.games (then use uploads/games/...) (crz.games is the url, not like crz.games.com or crzgames.com, just crz.games)
        this.base = "";
        // change this to true when deploying to crz.games
        if (window.location.hostname === "crz.games") {
            this.crzgames = true;
            this.base = "uploads/games/";
        }
        this.version = "mega-1"
        this.canvas = canvas;
        this.container = document.getElementById("gamecontainer");
        this.ctx = canvas.getContext("2d");
        this.keys = {};
        this.mouseDelta = { x: 0, y: 0 };
        this.mouseCapture = false;
        this.entities = [];
        this.EntityClasses = {};
        this.RUN_TYPE = "CLIENT"; // Can be CLIENT, SERVER, SHARED
        this.consoleOpen = false;
        this.consoleHistory = [];
        this.Transform = Transform;
        this.conCommands = {};
        this.conVars = {};
        this.keyBinds = {};
        this.game = game;
        this.debug = false;
        // Load binds from localStorage
        this.loadBinds();
        this._width = 1280;
        this._height = 720;
        console.log("CRE initialized for game:", game);
        console.log("this.game: ", this.game);
        // add convar for cheats and stuff
        this.cheats = this.RegisterConVar("sv_cheats", "0");
        this.fov = this.RegisterConVar("fov", "60");
        this.nearplane = this.RegisterConVar("near_plane", "0.01");
        this.farplane = this.RegisterConVar("far_plane", "1000");
        
        // Register built-in commands
        this.RegisterConCommand("ent_spawn", (...args) => this.SpawnEntity(args[0], ...args.slice(1)), FCVAR_CHEAT, "Spawn an entity");
        this.RegisterConCommand("game_reset", () => this.UTIL_RESET(), FCVAR_CHEAT, "Reset the game");
        this.RegisterConCommand("ent_remove", (name) => {
            const entity = this.entities.find(e => e.name === name);
            if (entity) this.UTIL_REMOVE(entity);
        }, FCVAR_CHEAT, "Remove an entity");
        this.RegisterConCommand("clear", () => document.getElementById('console-output').textContent = '', FCVAR_NONE, "Clear console output");
        this.RegisterConCommand("map_load", (mapName) => {
            fetch(`${this.base}${this.game}/maps/${mapName}.map?v=${Date.now()}`)
                .then(r => r.json())
                .then(data => this.LoadMap(data))
                .catch(() => this.addToConsole(`Failed to load map: ${mapName}`));
        }, FCVAR_NONE, "Load a map");
        this.RegisterConCommand("model_load", (modelName) => {
            this.LoadModel(modelName).then(model => {
                if (model) {
                    window.loadedModel = model;
                    this.addToConsole(`Model '${modelName}' loaded and available as window.loadedModel`);
                }
            });
        }, FCVAR_NONE, "Load a model");
        this.RegisterConCommand("width", (value) => {
            if (value) this.width = parseInt(value);
            this.addToConsole(`Width = ${this.width}`);
        }, FCVAR_NONE, "Set canvas width");
        this.RegisterConCommand("height", (value) => {
            if (value) this.height = parseInt(value);
            this.addToConsole(`Height = ${this.height}`);
        }, FCVAR_NONE, "Set canvas height");
        this.RegisterConCommand("bind", (key, ...commandParts) => {
            if (commandParts.length > 0) {
                const keyLower = key.toLowerCase();
                const command = commandParts.join(' ').replace(/"/g, '');
                this.keyBinds[keyLower] = command;
                this.saveBinds();
                this.addToConsole(`Bound ${keyLower} to "${command}"`);
            } else {
                this.addToConsole("Usage: bind <key> <command>");
            }
        }, FCVAR_NONE, "Bind a key to a command");
        this.RegisterConCommand("unbind", (key) => {
            if (key) {
                const keyLower = key.toLowerCase();
                if (this.keyBinds[keyLower]) {
                    delete this.keyBinds[keyLower];
                    this.saveBinds();
                    this.addToConsole(`Unbound ${keyLower}`);
                } else {
                    this.addToConsole(`${keyLower} is not bound`);
                }
            } else {
                this.addToConsole("Usage: unbind <key>");
            }
        }, FCVAR_NONE, "Unbind a key");
        this.RegisterConCommand("bindlist", () => {
            if (Object.keys(this.keyBinds).length === 0) {
                this.addToConsole("No key binds");
            } else {
                Object.entries(this.keyBinds).forEach(([key, cmd]) => {
                    this.addToConsole(`${key} = "${cmd}"`);
                });
            }
        }, FCVAR_NONE, "List all key binds");
        this.RegisterConCommand("toggledebug", () => this.debug = !this.debug, FCVAR_NONE, "Toggle debug display");
        this.RegisterConCommand("toggleconsole", () => this.toggleConsole(), FCVAR_NONE, "Toggle console visibility");
        this.RegisterConCommand("echo", (echo) => this.addToConsole(echo), FCVAR_NONE, "Echo to console");
        this.RegisterConCommand("help", (command) => {
            if (command) {
                // Check if it's a command
                if (this.conCommands[command]) {
                    const cmd = this.conCommands[command];
                    this.addToConsole(`${command}:`);
                    this.addToConsole(cmd.help);
                    return;
                }
                // Check if it's a convar
                if (this.conVars[command]) {
                    const cvar = this.conVars[command];
                    this.addToConsole(`${command} = "${cvar.value}"`);
                    this.addToConsole(`Default value: ${cvar.defaultValue}`)
                    this.addToConsole(`Current value: ${cvar.value}`)
                    return;
                }
                this.addToConsole(`Unknown command or variable: ${command}`);
            } else {
                this.addToConsole("Available commands:");
                Object.keys(this.conCommands).forEach(cmd => {
                    this.addToConsole(`  ${cmd} - ${this.conCommands[cmd].help}`);
                });
                this.addToConsole("Available variables:");
                Object.keys(this.conVars).forEach(cvar => {
                    this.addToConsole(`  ${cvar} - ${this.conVars[cvar].help}`);
                });
            }
        }, FCVAR_NONE, "Get help with a command or list all commands");
        // 3D Camera
        this.camera = {
            position: new Vector(0, 0, -10),
            rotation: new Vector(0, 0, 0),
            fov: 60,
            near: 0.01,
            far: 1000
        };

        this.models = {}

        // Setup input
        window.addEventListener("keydown", e => {
            if (!this.consoleOpen) {
                this.keys[e.key] = true;
            }
            // Check for key binds (only when console is closed or for special keys)
            if (this.keyBinds[e.key.toLowerCase()] && (!this.consoleOpen || e.key === '`')) {
                e.preventDefault();
                this.ConsoleHandler(...this.keyBinds[e.key.toLowerCase()].split(' '));
            }
        });
        window.addEventListener("keyup", e => {
            if (!this.consoleOpen) this.keys[e.key] = false;
        });
        
        // Mouse capture and movement
        this.canvas.addEventListener('click', () => {
            if (!this.mouseCapture) {
                this.canvas.requestPointerLock();
            }
        });
        
        document.addEventListener('pointerlockchange', () => {
            this.mouseCapture = document.pointerLockElement === this.canvas;
        });
        
        document.addEventListener('mousemove', e => {
            if (this.mouseCapture && !this.consoleOpen) {
                this.mouseDelta.x += e.movementX;
                this.mouseDelta.y += e.movementY;
            }
        });

        // Set fixed canvas size
        this.canvas.width = this._width;
        this.canvas.height = this._height;
        this.container.style.width = this._width + 'px';
        this.container.style.height = this._height + 'px';
        
        // Property setters for width/height
        Object.defineProperty(this, 'width', {
            get: () => this._width,
            set: (value) => {
                this._width = value;
                this.canvas.width = value;
                this.container.style.width = value + 'px';
            }
        });
        
        Object.defineProperty(this, 'height', {
            get: () => this._height,
            set: (value) => {
                this._height = value;
                this.canvas.height = value;
                this.container.style.height = value + 'px';
            }
        });

        // Enums for registration
        this.Enums = {
            RunType: {
                CLIENT: "CLIENT",
                SERVER: "SERVER",
                SHARED: "SHARED"
            },
            ConVarFlags: {
                NONE: FCVAR_NONE,
                CHEAT: FCVAR_CHEAT,
                REPLICATED: FCVAR_REPLICATED,
                ARCHIVE: FCVAR_ARCHIVE,
                NOTIFY: FCVAR_NOTIFY,
                USERINFO: FCVAR_USERINFO,
                PROTECTED: FCVAR_PROTECTED,
                SPONLY: FCVAR_SPONLY,
                DEMO: FCVAR_DEMO,
                DONTRECORD: FCVAR_DONTRECORD
            },
            DrawMode: {
                CUBE: 0,
                MODEL: 1,
                SPHERE: 2,
            }
        };

        // Start game loop
        this.lastTime = performance.now();
        requestAnimationFrame(this.gameLoop.bind(this));
    }


    
    // Register a class as an entity
    RegisterEntity(cls, name, runType = this.Enums.RunType.CLIENT) {
        this.EntityClasses[name] = { cls, runType };
    }

    ConsoleHandler(command, ...args) {
        this.addToConsole(`] ${command} ${args.join(' ')}`);
        
        // Check registered commands first
        if (this.conCommands[command]) {
            const concommand = this.conCommands[command];
            // Check if it's a cheat command and cheats are disabled
            if (concommand.hasFlag(FCVAR_CHEAT) && !this.GetConVar("sv_cheats")) {
                this.addToConsole(`Can't execute ${command}, cheats are not enabled.`);
                return;
            }
            concommand.execute(...args);
            return;
        }
        
        // Check convars
        if (this.conVars[command]) {
            if (args.length > 0) {
                const convar = this.conVars[command];
                // Check if it's a cheat convar and cheats are disabled
                if (convar.hasFlag(FCVAR_CHEAT) && !this.GetConVar("sv_cheats")) {
                    this.addToConsole(`Can't change ${command}, cheats are not enabled.`);
                    return;
                }
                convar.value = args[0];
                this.addToConsole(`${command} = ${args[0]}`);
            } else {
                this.addToConsole(`${command} = ${this.conVars[command].value}`);
            }
            return;
        }
        
        // Unknown command
        this.addToConsole(`Unknown command: ${command}`);
    }

    addToConsole(text) {
        const output = document.getElementById('console-output');
        output.textContent += text + '\n';
        output.scrollTop = output.scrollHeight;
    }

    toggleConsole() {
        this.consoleOpen = !this.consoleOpen;
        const console = document.getElementById('console');
        const input = document.getElementById('console-input');
        const suggestions = document.getElementById('console-suggestions');
        
        if (this.consoleOpen) {
            console.style.display = 'flex';
            input.focus();
        } else {
            console.style.display = 'none';
            input.blur();
            suggestions.style.display = 'none';
        }
    }

    // Add an instance of a registered entity
    SpawnEntity(name, ...args) {
        if (!this.EntityClasses[name]) {
            console.warn(`Entity ${name} not registered!`);
            return null;
        }
        const { cls, runType } = this.EntityClasses[name];
        // Only spawn if run type matches
        if (runType === this.RUN_TYPE || runType === this.Enums.RunType.SHARED) {
            const instance = new cls(...args);
            if (instance.init) instance.init();
            this.entities.push(instance);
            return instance;
        }
        return null;
    }

    // Check if a key is pressed
    isKeyPressed(key) {
        return !!this.keys[key];
    }
    
    // Register console command
    RegisterConCommand(name, func, flags, help) {
        this.conCommands[name] = new ConCommand(name, func, flags, help);
        return this.conCommands[name];
    }
    
    // Register console variable
    RegisterConVar(name, defaultValue, flags, help) {
        this.conVars[name] = new ConVar(name, defaultValue, flags, help);
        return this.conVars[name];
    }
    
    // Get convar value
    GetConVar(name) {
        return this.conVars[name] ? this.conVars[name].value : null;
    }
    
    // Load map from JSON
    LoadMap(mapData) {
        this.UTIL_RESET();
        this.brushes = [];
        
        // Load entities
        mapData.entities?.forEach(ent => {
            const instance = this.SpawnEntity(ent.type, ...ent.args || []);
            if (instance && ent.position) {
                instance.transform?.setPosition(...ent.position);
            }
            if (instance && ent.scale) {
                instance.transform?.setScale(...ent.scale);
            }
        });
        
        // Load brushes
        mapData.brushes?.forEach(brush => {
            this.brushes.push({
                vertices: brush.vertices.map(v => new Vector(v[0], v[1], v[2])),
                texture: brush.texture || "#666",
                faces: brush.faces || []
            });
        });
        
        this.addToConsole(`Map loaded: ${mapData.name || 'Unnamed'}`);
    }
    
    // Load model from JSON
    LoadModel(name, modelPath) {
        return fetch(`${this.base}${this.game}/models/${modelPath}.json?v=${Date.now()}`)
            .then(r => r.json())
            .then(data => {
                const model = {
                    objects: data.objects.map(obj => ({
                        name: obj.name,
                        vertices: obj.vertices.map(v => new Vector(v[0], v[1], v[2])),
                        faces: obj.faces,
                        normals: obj.normals?.map(n => new Vector(n[0], n[1], n[2])) || [],
                        uvs: obj.uvs || []
                    }))
                };
                if (this.debug) {
                    this.addToConsole(`Model loaded: ${modelPath}`);
                }
                this.models[name] = model;
                return model;
            })
            .catch(err => {
                this.addToConsole(`Failed to load model: ${modelPath}`);
                return null;
            });
    }
    
    // Render model
    drawModel(model, transform, color = "#888") {
        if (!model || !model.objects) return;
        
        model.objects.forEach(obj => {
            obj.faces.forEach(face => {
                if (face.length >= 3) {
                    // Fan triangulation for any polygon
                    for (let i = 1; i < face.length - 1; i++) {
                        const v1Idx = face[0][0] - 1;
                        const v2Idx = face[i][0] - 1;
                        const v3Idx = face[i + 1][0] - 1;
                        
                        if (v1Idx >= 0 && v2Idx >= 0 && v3Idx >= 0 && 
                            v1Idx < obj.vertices.length && v2Idx < obj.vertices.length && v3Idx < obj.vertices.length) {
                            
                            const v1 = this.transformVertex(obj.vertices[v1Idx], transform);
                            const v2 = this.transformVertex(obj.vertices[v2Idx], transform);
                            const v3 = this.transformVertex(obj.vertices[v3Idx], transform);
                            
                            // Calculate lighting like cubes
                            const ab = v2.subtract(v1);
                            const ac = v3.subtract(v1);
                            const worldNormal = ab.cross(ac).normalize();
                            const lightDir = new Vector(0.5, -1, 0.3).normalize();
                            const lightDot = worldNormal.dot(lightDir);
                            const shade = Math.max(0.3, Math.abs(lightDot));
                            
                            this.renderQueue.push({
                                type: 'triangle',
                                verts: [v1, v2, v3],
                                color: color,
                                shade
                            });
                        }
                    }
                }
            });
        });
    }
    
    // Transform vertex by transform matrix
    transformVertex(vertex, transform) {
        // Apply scale first
        let v = new Vector(
            vertex.x * transform.scale.x,
            vertex.y * transform.scale.y,
            vertex.z * transform.scale.z
        );
        
        // Apply rotation (negated to match expected direction)
        const yaw = -transform.rotation.y * Math.PI / 180;
        const pitch = -transform.rotation.x * Math.PI / 180;
        
        // Rotate around Y axis (yaw)
        const cosY = Math.cos(yaw);
        const sinY = Math.sin(yaw);
        const x1 = v.x * cosY - v.z * sinY;
        const z1 = v.x * sinY + v.z * cosY;
        
        // Rotate around X axis (pitch)
        const cosX = Math.cos(pitch);
        const sinX = Math.sin(pitch);
        const y2 = v.y * cosX - z1 * sinX;
        const z2 = v.y * sinX + z1 * cosX;
        
        // Apply position
        return new Vector(
            x1 + transform.position.x,
            y2 + transform.position.y,
            z2 + transform.position.z
        );
    }
    
    // Auto-load map function for game code
    LoadMapFromName(mapName) {
        fetch(`${this.base}${this.game}/maps/${mapName}.map?v=${Date.now()}`)
            .then(r => r.json())
            .then(data => {
                this.LoadMap(data);
                console.log(`Auto-loaded map: ${mapName}`);
            })
            .catch(err => {
                console.warn(`Failed to auto-load map: ${mapName}`, err);
            });
    }
    
    // Save binds to localStorage
    saveBinds() {
        localStorage.setItem(`crengine_binds_${this.game}`, JSON.stringify(this.keyBinds));
    }
    
    // Load binds from localStorage
    loadBinds() {
        const saved = localStorage.getItem(`crengine_binds_${this.game}`);
        if (saved) {
            try {
                this.keyBinds = JSON.parse(saved);
            } catch (e) {
                console.warn('Failed to load saved binds:', e);
            }
        }
    }
    
    // Set default bind if not already set
    setDefaultBind(key, command) {
        const k = key.toLowerCase();
        if (!this.keyBinds[k]) {
            this.keyBinds[k] = command;
            this.saveBinds();
        }
    }

    // Utility functions
    Msg(text) { 
        console.log(text);
        if (this.consoleOpen) this.addToConsole(text);
    }
    UTIL_RESET() { this.Msg("Game Reset!"); this.entities = []; }
    UTIL_REMOVE(entity) { this.entities = this.entities.filter(e => e !== entity); }
    
    // Simple GUI system
    drawGUI() {
        if (this.debug) {
            this.ctx.fillStyle = "white";
            this.ctx.font = "12px monospace";
            this.ctx.fillText(`Entities: ${this.entities.length}`, 10, 20);
        
            // Calculate FPS with proper bounds
            const frameTime = performance.now() - this.lastTime;
            const fps = frameTime > 0 ? Math.min(Math.round(1000 / frameTime), 999) : 0;
            const addplus = fps === 999 ? "+" : "";
            this.ctx.fillText(`FPS: ${fps}${addplus}`, 10, 35);
        
            if (this.camera.position) {
                this.ctx.fillText(`Pos: ${this.camera.position.x.toFixed(1)}, ${this.camera.position.y.toFixed(1)}, ${this.camera.position.z.toFixed(1)}`, 10, 50);
            }
            if (this.camera.rotation) {
                this.ctx.fillText(`Rot: ${this.camera.rotation.x.toFixed(1)}, ${this.camera.rotation.y.toFixed(1)}, ${this.camera.rotation.z.toFixed(1)}`, 10, 65);
            }
        }
    }

    // 3D projection with camera rotation
    project3D(pos) {
        const cx = this.canvas.width / 2;
        const cy = this.canvas.height / 2;
        const f = cx / Math.tan(this.camera.fov * Math.PI / 360);
        
        // Translate relative to camera
        let d = pos.subtract(this.camera.position);
        
        // Apply camera rotation
        const yaw = this.camera.rotation.y * Math.PI / 180;
        const pitch = this.camera.rotation.x * Math.PI / 180;
        
        // Rotate around Y axis (yaw)
        const cosY = Math.cos(yaw);
        const sinY = Math.sin(yaw);
        const x1 = d.x * cosY - d.z * sinY;
        const z1 = d.x * sinY + d.z * cosY;
        
        // Rotate around X axis (pitch)
        const cosX = Math.cos(pitch);
        const sinX = Math.sin(pitch);
        const y2 = d.y * cosX - z1 * sinX;
        const z2 = d.y * sinX + z1 * cosX;
        
        if (z2 <= this.camera.near) return null; // Behind near plane
        
        return new Vector(
            cx + (x1 * f) / z2,
            cy - (y2 * f) / z2,
            z2
        );
    }
    
    drawLine3D(pos1, pos2) {
        const p1 = this.project3D(pos1);
        const p2 = this.project3D(pos2);
        
        if (p1 && p2) {
            this.ctx.beginPath();
            this.ctx.moveTo(p1.x, p1.y);
            this.ctx.lineTo(p2.x, p2.y);
            this.ctx.stroke();
        }
    }
    
    // Clip triangle against near plane
    clipTriangle(v1, v2, v3) {
        const near = this.camera.near;

        const verts = [
            this.toCameraSpace(v1),
            this.toCameraSpace(v2),
            this.toCameraSpace(v3)
        ];

        const inside = [];
        const outside = [];

        verts.forEach(v => {
            if (v.z >= near) inside.push(v);
            else outside.push(v);
        });

        // Fully clipped
        if (inside.length === 0) return [];

        // Fully visible
        if (inside.length === 3) return [[inside[0], inside[1], inside[2]]];

        // One inside → one triangle
        if (inside.length === 1 && outside.length === 2) {
            const i = inside[0];
            const o1 = outside[0];
            const o2 = outside[1];

            const t1 = (near - i.z) / (o1.z - i.z);
            const t2 = (near - i.z) / (o2.z - i.z);

            return [[
                i,
                { x: i.x + t1 * (o1.x - i.x), y: i.y + t1 * (o1.y - i.y), z: near },
                { x: i.x + t2 * (o2.x - i.x), y: i.y + t2 * (o2.y - i.y), z: near }
            ]];
        }

        // Two inside → quad → two triangles
        if (inside.length === 2 && outside.length === 1) {
            const [i1, i2] = inside;
            const o = outside[0];

            const t1 = (near - i1.z) / (o.z - i1.z);
            const t2 = (near - i2.z) / (o.z - i2.z);

            const v1 = { x: i1.x + t1 * (o.x - i1.x), y: i1.y + t1 * (o.y - i1.y), z: near };
            const v2 = { x: i2.x + t2 * (o.x - i2.x), y: i2.y + t2 * (o.y - i2.y), z: near };

            return [
                [i1, i2, v1],
                [i2, v2, v1]
            ];
        }

        return [];
    }

    toCameraSpace(pos) {
        let d = pos.subtract(this.camera.position);
        
        const yaw = this.camera.rotation.y * Math.PI / 180;
        const pitch = this.camera.rotation.x * Math.PI / 180;
        
        const cosY = Math.cos(yaw);
        const sinY = Math.sin(yaw);
        const x1 = d.x * cosY - d.z * sinY;
        const z1 = d.x * sinY + d.z * cosY;
        
        const cosX = Math.cos(pitch);
        const sinX = Math.sin(pitch);
        const y2 = d.y * cosX - z1 * sinX;
        const z2 = d.y * sinX + z1 * cosX;
        
        return { x: x1, y: y2, z: z2 };
    }
    
    drawTriangle3D(v1, v2, v3, color = "white", shading = 1) {
        // Backface culling in camera space
        const ca = this.toCameraSpace(v1);
        const cb = this.toCameraSpace(v2);
        const cc = this.toCameraSpace(v3);
        
        const abx = cb.x - ca.x, aby = cb.y - ca.y, abz = cb.z - ca.z;
        const acx = cc.x - ca.x, acy = cc.y - ca.y, acz = cc.z - ca.z;
        const normalX = aby * acz - abz * acy;
        const normalY = abz * acx - abx * acz;
        const normalZ = abx * acy - aby * acx;
        
        const centerX = (ca.x + cb.x + cc.x) / 3;
        const centerY = (ca.y + cb.y + cc.y) / 3;
        const centerZ = (ca.z + cb.z + cc.z) / 3;
        
        const dot = normalX * (-centerX) + normalY * (-centerY) + normalZ * (-centerZ);
        if (dot <= 0) return; // Skip back-facing triangles
        
        const clippedTris = this.clipTriangle(v1, v2, v3);
        if (!clippedTris || clippedTris.length === 0) return;

        const cx = this.canvas.width / 2;
        const cy = this.canvas.height / 2;
        const f = cx / Math.tan(this.camera.fov * Math.PI / 360);

        let shadedColor = color;
        if (color.startsWith('#')) {
            const clamp = v => Math.max(0, Math.min(255, v));
            const r = clamp(parseInt(color.slice(1, 3), 16) * shading);
            const g = clamp(parseInt(color.slice(3, 5), 16) * shading);
            const b = clamp(parseInt(color.slice(5, 7), 16) * shading);
            shadedColor = `rgb(${r|0}, ${g|0}, ${b|0})`;
        }

        this.ctx.fillStyle = shadedColor;
        this.ctx.strokeStyle = shadedColor;
        this.ctx.lineWidth = 1;

        for (const tri of clippedTris) {
            const projected = tri.map(v => ({
                x: cx + (v.x * f) / v.z,
                y: cy - (v.y * f) / v.z
            }));

            this.ctx.beginPath();
            this.ctx.moveTo(projected[0].x, projected[0].y);
            this.ctx.lineTo(projected[1].x, projected[1].y);
            this.ctx.lineTo(projected[2].x, projected[2].y);
            this.ctx.closePath();
            this.ctx.fill();
            this.ctx.stroke();
        }
    }

    
    // Apply rotation to a vertex
    rotateVertex(vertex, rotation, center) {
        let v = vertex.subtract(center);
        
        // Rotate around Y axis (yaw) - reversed
        const yaw = -rotation.y * Math.PI / 180;
        const cosY = Math.cos(yaw);
        const sinY = Math.sin(yaw);
        const x1 = v.x * cosY - v.z * sinY;
        const z1 = v.x * sinY + v.z * cosY;
        
        // Rotate around X axis (pitch) - reversed
        const pitch = -rotation.x * Math.PI / 180;
        const cosX = Math.cos(pitch);
        const sinX = Math.sin(pitch);
        const y2 = v.y * cosX - z1 * sinX;
        const z2 = v.y * sinX + z1 * cosX;
        
        // Rotate around Z axis (roll) - reversed
        const roll = -rotation.z * Math.PI / 180;
        const cosZ = Math.cos(roll);
        const sinZ = Math.sin(roll);
        const x3 = x1 * cosZ - y2 * sinZ;
        const y3 = x1 * sinZ + y2 * cosZ;
        
        return center.add(new Vector(x3, y3, z2));
    }
    
    drawCube3D(transform) {
        const pos = new Vector(transform.position.x, transform.position.y, transform.position.z);
        const scale = transform.scale;
        const rotation = transform.rotation;
        
        // Base cube vertices (unrotated)
        const baseVertices = [
            new Vector(-scale.x, -scale.y, -scale.z), new Vector(scale.x, -scale.y, -scale.z),
            new Vector(scale.x, scale.y, -scale.z), new Vector(-scale.x, scale.y, -scale.z),
            new Vector(-scale.x, -scale.y, scale.z), new Vector(scale.x, -scale.y, scale.z),
            new Vector(scale.x, scale.y, scale.z), new Vector(-scale.x, scale.y, scale.z)
        ];
        
        // Apply rotation and position
        const v = baseVertices.map(vertex => 
            this.rotateVertex(vertex, rotation, new Vector(0, 0, 0)).add(pos)
        );
        
        // Create faces with z-depth for sorting
        const faces = [
            {verts: [v[0],v[3],v[2]], shade: 0.6}, {verts: [v[0],v[2],v[1]], shade: 0.6}, // back
            {verts: [v[4],v[5],v[6]], shade: 1.0}, {verts: [v[4],v[6],v[7]], shade: 1.0}, // front
            {verts: [v[0],v[1],v[5]], shade: 0.4}, {verts: [v[0],v[5],v[4]], shade: 0.4}, // bottom
            {verts: [v[2],v[3],v[7]], shade: 0.9}, {verts: [v[2],v[7],v[6]], shade: 0.9}, // top
            {verts: [v[0],v[4],v[7]], shade: 0.7}, {verts: [v[0],v[7],v[3]], shade: 0.7}, // left
            {verts: [v[1],v[2],v[6]], shade: 0.8}, {verts: [v[1],v[6],v[5]], shade: 0.8}  // right
        ];
        
        // Add faces to render queue
        faces.forEach(({verts: [a,b,c], shade}) => {
            this.renderQueue.push({
                type: 'triangle',
                verts: [a, b, c],
                color: "#888888",
                shade
            });
        });
    }

    // Main game loop
    gameLoop(now) {
        const dt = (now - this.lastTime) / 1000;
        this.lastTime = now;

        // update any convar stuff
        this.camera.fov = parseFloat(this.GetConVar("fov")) || 60;
        this.camera.near = parseFloat(this.GetConVar("near_plane")) || 0.01;
        this.camera.far = parseFloat(this.GetConVar("far_plane")) || 1000;
        // update 

        // Update entities
        this.entities.forEach(ent => {
            if (ent.update) {
                try {
                    ent.update(dt, this);
                } catch (e) {
                    if (!gameHalted) showError(e);
                }
            }
        });

        // Clear and prepare render queue
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.renderQueue = [];
        
        // Add brushes to render queue
        if (this.brushes) {
            this.brushes.forEach(brush => {
                brush.faces.forEach(face => {
                    for (let i = 1; i < face.length - 1; i++) {
                        const v1 = brush.vertices[face[0]];
                        const v2 = brush.vertices[face[i]];
                        const v3 = brush.vertices[face[i + 1]];
                        
                        // Calculate world space normal for lighting
                        const ab = v2.subtract(v1);
                        const ac = v3.subtract(v1);
                        const worldNormal = ab.cross(ac).normalize();
                        
                        // Calculate lighting in world space
                        const lightDir = new Vector(0.5, -1, 0.3).normalize();
                        const lightDot = worldNormal.dot(lightDir);
                        const shade = Math.max(0.3, Math.abs(lightDot));
                        
                        // Backface culling in camera space
                        const ca = this.toCameraSpace(v1);
                        const cb = this.toCameraSpace(v2);
                        const cc = this.toCameraSpace(v3);
                        
                        const abx = cb.x - ca.x, aby = cb.y - ca.y, abz = cb.z - ca.z;
                        const acx = cc.x - ca.x, acy = cc.y - ca.y, acz = cc.z - ca.z;
                        const normalX = aby * acz - abz * acy;
                        const normalY = abz * acx - abx * acz;
                        const normalZ = abx * acy - aby * acx;
                        
                        const centerX = (ca.x + cb.x + cc.x) / 3;
                        const centerY = (ca.y + cb.y + cc.y) / 3;
                        const centerZ = (ca.z + cb.z + cc.z) / 3;
                        
                        const dot = normalX * (-centerX) + normalY * (-centerY) + normalZ * (-centerZ);
                        
                        if (dot > 0) {
                            
                            const centroidZ = (ca.z + cb.z + cc.z) / 3;

                            this.renderQueue.push({
                                type: 'triangle',
                                verts: [v1, v2, v3],
                                color: brush.texture,
                                shade,
                                centroidZ
                            });
                        }
                    }
                });
            });
        }
        
        // Add 3D entities to render queue
        this.entities.forEach(ent => {
            if (ent.CRE.drawmode === undefined || ent.CRE.drawmode === null) {return;};
            if (!(ent.CRE.transform)) {return;};
            if (ent.CRE.drawmode === this.Enums.DrawMode.CUBE) {
                this.drawCube3D(ent.CRE.transform);
            } else if (ent.CRE.drawmode === this.Enums.DrawMode.MODEL) {
                if (!(ent.CRE.model)) {return;}
                const color = "#aaa"
                //if (ent.CRE.color) {
                //    color = String(ent.CRE.color);
                //}
                const model = this.getModel(ent.CRE.model);
                if (model) this.drawModel(model, ent.CRE.transform, color);
            }
        });
        
        // Add centroid Z to all triangles for sorting
        this.renderQueue.forEach(item => {
            if (item.type === 'triangle') {
                const ca = this.toCameraSpace(item.verts[0]);
                const cb = this.toCameraSpace(item.verts[1]);
                const cc = this.toCameraSpace(item.verts[2]);
                item.centroidZ = (ca.z + cb.z + cc.z) / 3;
            }
        });
        
        // Sort by centroid Z depth (back to front)
        this.renderQueue.sort((a, b) => b.centroidZ - a.centroidZ);
        
        this.renderQueue.forEach(item => {
            if (item.type === 'triangle') {
                this.drawTriangle3D(item.verts[0], item.verts[1], item.verts[2], item.color, item.shade);
            }
        });
        
        // Draw GUI
        this.drawGUI();

        requestAnimationFrame(this.gameLoop.bind(this));
    }

    getModel(modelname) {
        return this.models[modelname] || null; 
    }
    
    trianglesIntersect(a, b) {
        if (a.type !== 'triangle' || b.type !== 'triangle') return false;
        const [a1, a2, a3] = a.verts.map(v => this.toCameraSpace(v));
        const [b1, b2, b3] = b.verts.map(v => this.toCameraSpace(v));
        return this.triangleTriangleIntersect(a1, a2, a3, b1, b2, b3);
    }
    
    triangleTriangleIntersect(t1v1, t1v2, t1v3, t2v1, t2v2, t2v3) {
        const n1 = this.crossProduct(this.subtract(t1v2, t1v1), this.subtract(t1v3, t1v1));
        const d1 = -this.dotProduct(n1, t1v1);
        const dist2 = [t2v1, t2v2, t2v3].map(v => this.dotProduct(n1, v) + d1);
        const sign2 = dist2.map(d => Math.sign(d));
        if (sign2[0] === sign2[1] && sign2[1] === sign2[2] && sign2[0] !== 0) return false;
        
        const n2 = this.crossProduct(this.subtract(t2v2, t2v1), this.subtract(t2v3, t2v1));
        const d2 = -this.dotProduct(n2, t2v1);
        const dist1 = [t1v1, t1v2, t1v3].map(v => this.dotProduct(n2, v) + d2);
        const sign1 = dist1.map(d => Math.sign(d));
        if (sign1[0] === sign1[1] && sign1[1] === sign1[2] && sign1[0] !== 0) return false;
        
        return true;
    }
    
    compareIntersectingTriangles(a, b) {
        const aCentroid = this.getTriangleCentroid(a.verts);
        const bCentroid = this.getTriangleCentroid(b.verts);
        const aDepth = this.toCameraSpace(aCentroid).z;
        const bDepth = this.toCameraSpace(bCentroid).z;
        return bDepth - aDepth;
    }
    
    getTriangleCentroid(verts) {
        const [v1, v2, v3] = verts;
        return new Vector((v1.x + v2.x + v3.x) / 3, (v1.y + v2.y + v3.y) / 3, (v1.z + v2.z + v3.z) / 3);
    }
    
    crossProduct(a, b) {
        return { x: a.y * b.z - a.z * b.y, y: a.z * b.x - a.x * b.z, z: a.x * b.y - a.y * b.x };
    }
    
    dotProduct(a, b) {
        return a.x * b.x + a.y * b.y + a.z * b.z;
    }
    
    subtract(a, b) {
        return { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };
    }
}
class Transform {
    constructor() {
        this.position = new Vector(0, 0, 0);
        this.rotation = new Vector(0, 0, 0);
        this.scale = new Vector(1, 1, 1);
    }
    getPosition() { return this.position; }
    setPosition(x, y, z) { this.position = new Vector(x, y, z); }
    getRotation() { return this.rotation; }
    setRotation(x, y, z) { this.rotation = new Vector(x, y, z); }
    getScale() { return this.scale; }
    setScale(x, y, z) { this.scale = new Vector(x, y, z); }
    getForwardVector() {
        const yaw = this.rotation.y * Math.PI / 180;
        const pitch = this.rotation.x * Math.PI / 180;
        return new Vector(
            Math.sin(yaw) * Math.cos(pitch),
            -Math.sin(pitch),
            Math.cos(yaw) * Math.cos(pitch)
        );
    }
    getRightVector() {
        const yaw = this.rotation.y * Math.PI / 180;
        return new Vector(
            Math.cos(yaw),
            0,
            -Math.sin(yaw)
        );
    }
    getUpVector() {
        return new Vector(0, 1, 0);
    }
}
class Vector {
    constructor(x = 0, y = 0, z = 0) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    add(v) {
        return new Vector(this.x + v.x, this.y + v.y, this.z + v.z);
    }
    
    dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
    }
    
    cross(v) {
        return new Vector(
            this.y * v.z - this.z * v.y,
            this.z * v.x - this.x * v.z,
            this.x * v.y - this.y * v.x
        );
    }

    subtract(v) {
        return new Vector(this.x - v.x, this.y - v.y, this.z - v.z);
    }

    multiply(scalar) {
        return new Vector(this.x * scalar, this.y * scalar, this.z * scalar);
    }

    divide(scalar) {
        return new Vector(this.x / scalar, this.y / scalar, this.z / scalar);
    }

    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }

    normalize() {
        const len = this.length();
        if (len === 0) return new Vector(0, 0, 0);
        return this.divide(len);
    }

    average() {
        return (this.x + this.y + this.z) / 3
    }

    distance(v) {
        return Math.sqrt((this.x - v.x) ** 2 + (this.y - v.y) ** 2 + (this.z - v.z) ** 2);
    }
}
// ConVar flags
const FCVAR_NONE = 0;
const FCVAR_CHEAT = 1;
const FCVAR_REPLICATED = 2;
const FCVAR_ARCHIVE = 4;
const FCVAR_NOTIFY = 8;
const FCVAR_USERINFO = 16;
const FCVAR_PROTECTED = 32;
const FCVAR_SPONLY = 64;
const FCVAR_DEMO = 128;
const FCVAR_DONTRECORD = 256;

class ConVar {
    constructor(name, defaultValue, flags, help) {
        this.name = name;
        this.value = defaultValue;
        this.flags = flags || FCVAR_NONE;
        this.help = help || "";
        this.defaultValue = defaultValue || "0";
    }
    
    hasFlag(flag) {
        return (this.flags & flag) !== 0;
    }
    getAsNumber() {
        return parseFloat(this.value);
    }
    getAsString() {
        return String(this.value);
    }
    getAsBoolean() {
        return this.value === '1' || this.value.toLowerCase() === 'true';
    }
    
}

class ConCommand {
    constructor(name, func, flags, help) {
        this.name = name;
        this.func = func;
        this.flags = flags || FCVAR_NONE;
        this.help = help || "";
    }
    hasFlag(flag) {
        return (this.flags & flag) !== 0;
    }
    execute(...args) {
        if (this.func) {
            this.func(...args);
        }
    }
}

const urlParams = new URLSearchParams(window.location.search);
const gameName = urlParams.get('game') || 'game';
// --- Initialize CRE ---
const cre = new CRE(document.getElementById("gameCanvas"), gameName);
console.log("CRENGINE initialized");
console.log("Loading game:", gameName);
window.CRE = cre; // Make CRE instance globally available

// Get game name from URL parameter

// if from crz.games, put uploads/games at the start of the path
let baseURL = "";
if (document.referrer.includes("crz.games")) {
    baseURL = "uploads/games/";
    cre.base = "uploads/games/";
}

let gameHalted = false;
let gameCode = null;

function showError(error) {
    const popup = document.getElementById('errorPopup');
    popup.innerHTML = `
        <h3>Runtime Error</h3>
        <pre>${error.message}\n${error.stack}</pre>
        <div>
            <button onclick="continueGame()">Continue</button>
            <button onclick="restartGame()">Restart</button>
            <button onclick="haltGame()">Halt</button>
        </div>
    `;
    popup.style.display = 'block';
}

function continueGame() {
    document.getElementById('errorPopup').style.display = 'none';
    gameHalted = false;
}

function restartGame() {
    document.getElementById('errorPopup').style.display = 'none';
    gameHalted = false;
    cre.UTIL_RESET();
    if (gameCode) {
        try {
            new Function("CRE", gameCode)(cre);
        } catch (e) {
            showError(e);
        }
    }
}

function haltGame() {
    gameHalted = true;
    document.getElementById('errorPopup').style.display = 'none';
}

window.onerror = (msg, file, line, col, error) => {
    if (!gameHalted) showError(error || new Error(msg));
    return true;
};

window.addEventListener('unhandledrejection', e => {
    if (!gameHalted) showError(e.reason);
});

fetch(`${baseURL}${gameName}/bin/client.cre?v=${Date.now()}`)
  .then(r => r.text())
  .then(code => {
    gameCode = code;
    const firstLine = code.split('\n')[0];
    
    if (!firstLine.startsWith('//{"META":')) {
        cre.Msg("No meta tag");
        try {
            new Function("CRE", code)(cre);
        } catch (e) {
            showError(e);
        }
        return;
    }
    
    try {
        const metaJson = firstLine.substring(2);
        const meta = JSON.parse(metaJson);
        
        if (meta.META && meta.META.version && meta.META.version !== cre.version) {
            if (confirm(`Wrong version, do you want to try anyway?`)) {
                new Function("CRE", code)(cre);
            }
        } else {
            new Function("CRE", code)(cre);
        }
    } catch (e) {
        if (e.name === 'SyntaxError') {
            cre.Msg("Invalid meta tag format");
        }
        showError(e);
    }
  })
  .catch(() => {
    cre.Msg(`Failed to load ${gameName}/bin/client.cre, loading default game.cre`);
    return fetch(`game.cre?v=${Date.now()}`)
      .then(r => r.text())
      .then(code => {
        gameCode = code;
        try {
            new Function("CRE", code)(cre);
        } catch (e) {
            showError(e);
        }
      });
  }); 
// Console toggle and input handling

const consoleInput = document.getElementById('console-input');
const suggestions = document.getElementById('console-suggestions');
let selectedSuggestionIndex = 0;

consoleInput.addEventListener('input', e => {
    const input = e.target.value;
    if (input.length > 0) {
        const allCommands = [...Object.keys(cre.conCommands), ...Object.keys(cre.conVars)];
        const matches = allCommands.filter(cmd => cmd.startsWith(input)).slice(0, 5);
        
        if (matches.length > 0) {
            suggestions.innerHTML = matches.map(cmd => `<div class="suggestion">${cmd}</div>`).join('');
            suggestions.style.display = 'block';
            
            // Add click handlers
            suggestions.querySelectorAll('.suggestion').forEach(el => {
                el.onclick = () => {
                    consoleInput.value = el.textContent;
                    suggestions.style.display = 'none';
                    consoleInput.focus();
                };
            });
        } else {
            suggestions.style.display = 'none';
        }
    } else {
        suggestions.style.display = 'none';
    }
});

consoleInput.addEventListener('keydown', e => {
    if (e.key === 'Tab') {
        e.preventDefault();

        const items = suggestions.querySelectorAll('.suggestion');
        if (items.length === 0) return;

        selectedSuggestionIndex %= items.length;
        consoleInput.value = items[selectedSuggestionIndex].textContent;
        selectedSuggestionIndex++;
        suggestions.style.display = 'none';
        consoleInput.focus();
        return;
    }

    if (e.key === 'Enter') {
        const command = e.target.value.trim();
        if (command) {
            const parts = command.split(' ');
            cre.ConsoleHandler(parts[0], ...parts.slice(1));
            e.target.value = '';
            suggestions.style.display = 'none';
            selectedSuggestionIndex = 0;
        }
    }
});

</script>
</body>
</html>
